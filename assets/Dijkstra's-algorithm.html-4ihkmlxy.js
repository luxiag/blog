import{_ as n,e as a,g as l,o as p}from"./app-Dt3FNJM0.js";const e="/blog/assets/168012340-11-22-16-58-00-C0oCsQ31.png",o={};function F(t,s){return p(),a("div",null,s[0]||(s[0]=[l('<h1 id="狄克斯特拉算法" tabindex="-1"><a class="header-anchor" href="#狄克斯特拉算法"><span>狄克斯特拉算法</span></a></h1><p><strong>Dijkstra算法的前提：</strong></p><ul><li>首先，Dijkstra处理的是带正权值的 有权图，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达( 边)的权值大小。(邻接矩阵或者邻接表存储)</li><li>其次，还需要一个boolean数组判断那些点已经确定最短长度，那些点没有确定。int数组记录距离(在算法执行过程可能被多次更新)。</li><li>需要优先队列加入已经确定点的周围点。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。</li></ul><p><strong>简单的概括流程为：</strong></p><p>一般从选定点开始抛入优先队列。（路径一般为0）， boolean数组标记0的位置(最短为0) , 然后0 周围连通的点抛入优先队列中（可能是node类），并把各个点的距离记录到对应数组内(如果小于就更新，大于就不动，初始第一次是无穷肯定会更新)，第一次就结束了 从队列中抛出 距离最近的那个点 B（第一次就是0周围邻居）。这个点距离一定是最近的（所有权值都是正的，点的距离只能越来越长。）标记这个点为 true，并且将这个点的邻居加入队列(下一次确定的最短点在前面未确定和这个点邻居中产生),并更新通过 B点计算各个位置的长度，如果小于则更新！</p><p><strong>Dijkstra 算法是一种贪心算法</strong></p><ul><li>(1) 找出最便宜的节点，即可在最短时间内前往的节点。</li><li>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。</li><li>(3) 重复这个过程，直到对图中的每个节点都这样做了。</li><li>(4) 计算最终路径。</li></ul><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;">//A B C D E F</span></span>
<span class="line"><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> graph </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> [</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//A  A=&gt;B=2 A=&gt;C=4</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//B  B=&gt;C=1 B=&gt;D=4 B=&gt;E=2</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//C</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//D</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//E</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//F</span></span>
<span class="line"><span style="color:#F8F8F2;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;">// graph 邻接矩阵</span></span>
<span class="line"><span style="color:#6272A4;">// src 起点</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#50FA7B;"> dijkstra</span><span style="color:#FF79C6;"> =</span><span style="color:#F8F8F2;"> (</span><span style="color:#FFB86C;font-style:italic;">graph</span><span style="color:#FF79C6;">:</span><span style="color:#8BE9FD;font-style:italic;"> number</span><span style="color:#F8F8F2;">[][], </span><span style="color:#FFB86C;font-style:italic;">src</span><span style="color:#FF79C6;">:</span><span style="color:#8BE9FD;font-style:italic;"> number</span><span style="color:#F8F8F2;">) </span><span style="color:#FF79C6;">=&gt;</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> dist </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> []; </span><span style="color:#6272A4;">// 储存当前A顶点到其它各个顶点间的距离</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> visited </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> []; </span><span style="color:#6272A4;">//储存ABCDEF顶点是否被访问过，以免重复访问，形成环</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> length </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> graph.length; </span><span style="color:#6272A4;">//储存所有顶点的数量</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> INF </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> Number.MAX_SAFE_INTEGER; </span><span style="color:#6272A4;">//Number javascript的最大整数  9007199254740991</span></span>
<span class="line"><span style="color:#6272A4;">  //初始化</span></span>
<span class="line"><span style="color:#FF79C6;">  for</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">; i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> length; i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    dist[i] </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> INF;</span></span>
<span class="line"><span style="color:#F8F8F2;">    visited[i] </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> false</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#6272A4;">  //第一个节点</span></span>
<span class="line"><span style="color:#F8F8F2;">  dist[src] </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">  while</span><span style="color:#F8F8F2;"> (i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> length </span><span style="color:#FF79C6;">-</span><span style="color:#BD93F9;"> 1</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#6272A4;">    //此时对应节点 已经访问设置 true</span></span>
<span class="line"><span style="color:#F8F8F2;">    visited[src] </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> true</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#6272A4;">    //找到对应节点 的 对应的边集合</span></span>
<span class="line"><span style="color:#FF79C6;">    let</span><span style="color:#F8F8F2;"> currentEdges </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> graph[src];</span></span>
<span class="line"><span style="color:#6272A4;">    //遍历边,更新路径</span></span>
<span class="line"><span style="color:#FF79C6;">    for</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">; i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> currentEdges.length; i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#FF79C6;">      if</span><span style="color:#F8F8F2;"> (currentEdges[i] </span><span style="color:#FF79C6;">!==</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#6272A4;">        //存在边 , 找到最短路径  例如</span></span>
<span class="line"><span style="color:#6272A4;">        //A=&gt;B=&gt;C 最短路径的权</span></span>
<span class="line"><span style="color:#6272A4;">        //为 A=&gt;B 的权(dist[src]) +  B=&gt;C的权(currentEdegs[i]) 和 A=&gt;C(dist[i]) 的权 进行比较</span></span>
<span class="line"><span style="color:#FF79C6;">        if</span><span style="color:#F8F8F2;"> (dist[src] </span><span style="color:#FF79C6;">+</span><span style="color:#F8F8F2;"> currentEdges[i] </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> dist[i]) {</span></span>
<span class="line"><span style="color:#6272A4;">          //符合上面条件 更新dist[i] 保证dist[i]是每次探路的最短路径</span></span>
<span class="line"><span style="color:#F8F8F2;">          dist[i] </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> currentEdges[i] </span><span style="color:#FF79C6;">+</span><span style="color:#F8F8F2;"> dist[src];</span></span>
<span class="line"><span style="color:#F8F8F2;">        }</span></span>
<span class="line"><span style="color:#F8F8F2;">      }</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"><span style="color:#6272A4;">    //迪杰斯特拉的核心算法 , 找到最短路径 重新探路.</span></span>
<span class="line"><span style="color:#6272A4;">    //选择最短路径</span></span>
<span class="line"><span style="color:#FF79C6;">    let</span><span style="color:#F8F8F2;"> min </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> INF;</span></span>
<span class="line"><span style="color:#FF79C6;">    let</span><span style="color:#F8F8F2;"> minIndex </span><span style="color:#FF79C6;">=</span><span style="color:#FF79C6;"> -</span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">    for</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">; i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> dist.length; i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#FF79C6;">      if</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">!</span><span style="color:#F8F8F2;">visited[i] </span><span style="color:#FF79C6;">&amp;&amp;</span><span style="color:#F8F8F2;"> dist[i] </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> min) {</span></span>
<span class="line"><span style="color:#F8F8F2;">        min </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> dist[i];</span></span>
<span class="line"><span style="color:#F8F8F2;">        minIndex </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> i;</span></span>
<span class="line"><span style="color:#F8F8F2;">      }</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6272A4;">    //进入下一次循环</span></span>
<span class="line"><span style="color:#F8F8F2;">    src </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> minIndex;</span></span>
<span class="line"><span style="color:#F8F8F2;">    i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#FF79C6;">  return</span><span style="color:#F8F8F2;"> dist;</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h1><ul><li><a href="https://zhuanlan.zhihu.com/p/114203860" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/114203860</a></li></ul>`,12)]))}const c=n(o,[["render",F],["__file","Dijkstra's-algorithm.html.vue"]]),i=JSON.parse(`{"path":"/algorithm/Dijkstra's-algorithm.html","title":"狄克斯特拉算法","lang":"en-US","frontmatter":{"title":"狄克斯特拉算法","reference":"算法图解","date":"2022-09-30T00:00:00.000Z","category":["算法"],"tag":["算法图解"],"description":"狄克斯特拉算法 Dijkstra算法的前提： 首先，Dijkstra处理的是带正权值的 有权图，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达( 边)的权值大小。(邻接矩阵或者邻接表存储) 其次，还需要一个boolean数组判断那些点已经确定最短长度，那些点没有确定。int数组记录距离(在算法执行过程可能被多次更新)。 需要优先队列...","head":[["meta",{"property":"og:url","content":"https://luxiag.github.io/luxiag/blog/algorithm/Dijkstra's-algorithm.html"}],["meta",{"property":"og:title","content":"狄克斯特拉算法"}],["meta",{"property":"og:description","content":"狄克斯特拉算法 Dijkstra算法的前提： 首先，Dijkstra处理的是带正权值的 有权图，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达( 边)的权值大小。(邻接矩阵或者邻接表存储) 其次，还需要一个boolean数组判断那些点已经确定最短长度，那些点没有确定。int数组记录距离(在算法执行过程可能被多次更新)。 需要优先队列..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-09T14:06:21.000Z"}],["meta",{"property":"article:tag","content":"算法图解"}],["meta",{"property":"article:published_time","content":"2022-09-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-09T14:06:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"狄克斯特拉算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-09-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-09T14:06:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luxiag\\",\\"url\\":\\"https://luxiag.github.io/luxiag\\"}]}"]]},"git":{"createdTime":1664978887000,"updatedTime":1739109981000,"contributors":[{"name":"卢祥","username":"卢祥","email":"example@gmail.com","commits":1,"url":"https://github.com/卢祥"},{"name":"luxiang","username":"luxiang","email":"luxiag@qq.com","commits":2,"url":"https://github.com/luxiang"},{"name":"卢祥","username":"卢祥","email":"example@email.com","commits":1,"url":"https://github.com/卢祥"},{"name":"luxiag","username":"luxiag","email":"luxiag@qq.com","commits":4,"url":"https://github.com/luxiag"},{"name":"卢祥","username":"卢祥","email":"example@qq.com","commits":4,"url":"https://github.com/卢祥"}]},"readingTime":{"minutes":3.06,"words":919},"filePathRelative":"algorithm/Dijkstra's-algorithm.md","localizedDate":"September 30, 2022","excerpt":"\\n<p><strong>Dijkstra算法的前提：</strong></p>\\n<ul>\\n<li>首先，Dijkstra处理的是带正权值的 有权图，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达( 边)的权值大小。(邻接矩阵或者邻接表存储)</li>\\n<li>其次，还需要一个boolean数组判断那些点已经确定最短长度，那些点没有确定。int数组记录距离(在算法执行过程可能被多次更新)。</li>\\n<li>需要优先队列加入已经确定点的周围点。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。</li>\\n</ul>","autoDesc":true}`);export{c as comp,i as data};
