import{_ as t,c as o,b as d,o as n}from"./app-CbWMe_xu.js";const l="/blog/assets/3297481732431458539-IklzyUTW.png",r="/blog/assets/3297481732432751600-BshC-yLW.png",s="/blog/assets/3297481732432954638-CRD958qW.png",c="/blog/assets/3297481732432962894-B1m089I6.png",i="/blog/assets/3297481732433005766-BzA7RJdi.png",a="/blog/assets/3297481732433080966-CsYCnHX_.png",p="/blog/assets/3297481732433867095-CoLMjhyp.png",g="/blog/assets/3297481732434036744-B3q_vL_l.png",h={};function u(m,e){return n(),o("div",null,e[0]||(e[0]=[d('<h1 id="cli" tabindex="-1"><a class="header-anchor" href="#cli"><span>CLI</span></a></h1><p><code>docker version</code></p><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>Client</strong>: 表示 Docker 客户端的版本信息。 <ul><li><strong>Docker Engine - Community</strong>: Docker 客户端的类型，这里是社区版。</li><li><strong>Version</strong>: 客户端的版本号。</li><li><strong>API version</strong>: 客户端支持的最高 Docker API 版本。</li><li><strong>Go version</strong>: 构建 Docker 客户端所使用的 Go 语言版本。</li><li><strong>Git commit</strong>: 客户端版本的 Git 提交哈希值。</li><li><strong>Built</strong>: 客户端构建的时间。</li><li><strong>OS/Arch</strong>: 客户端运行的操作系统和架构。</li><li><strong>Experimental</strong>: 表示是否启用了实验性功能。</li></ul></li><li><strong>Server</strong>: 表示 Docker 服务器的版本信息，通常指的是 Docker 引擎。 <ul><li><strong>Engine</strong>: Docker 引擎的详细版本信息。 <ul><li><strong>Version</strong>: 引擎的版本号。</li><li><strong>API version</strong>: 引擎支持的 Docker API 版本，后面通常会注明最低支持的 API 版本。</li><li><strong>Go version</strong>: 构建 Docker 引擎所使用的 Go 语言版本。</li><li><strong>Git commit</strong>: 引擎版本的 Git 提交哈希值。</li><li><strong>Built</strong>: 引擎构建的时间。</li><li><strong>OS/Arch</strong>: 引擎运行的操作系统和架构。</li><li><strong>Experimental</strong>: 表示是否启用了实验性功能。</li></ul></li></ul></li></ul><h1 id="image-and-container" tabindex="-1"><a class="header-anchor" href="#image-and-container"><span>Image and Container</span></a></h1><h2 id="image" tabindex="-1"><a class="header-anchor" href="#image"><span>Image</span></a></h2><ul><li>镜像类似模板</li><li>read-only 文件</li></ul><h2 id="container" tabindex="-1"><a class="header-anchor" href="#container"><span>container</span></a></h2><ul><li>一个运行中的 docker image</li><li>实质是复制了 image，并添加了可写层</li><li>基于同一个image可以创建多个container</li></ul><h1 id="container-1" tabindex="-1"><a class="header-anchor" href="#container-1"><span>container</span></a></h1><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;"># 创建容器</span></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> container</span><span style="color:#F1FA8C;"> run</span><span style="color:#F1FA8C;"> nginx</span></span>
<span class="line"></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> container</span><span style="color:#F1FA8C;"> ls</span></span>
<span class="line"><span style="color:#6272A4;"># 等价于</span></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> ls</span></span>
<span class="line"></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> stop</span><span style="color:#F1FA8C;"> container_id</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6272A4;"># 删除容器</span></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> container</span><span style="color:#F1FA8C;"> rm</span><span style="color:#F1FA8C;"> container_id</span></span>
<span class="line"><span style="color:#6272A4;"># 等价于</span></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> rm</span><span style="color:#F1FA8C;"> container_id</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h2><h3 id="容器生命周期管理" tabindex="-1"><a class="header-anchor" href="#容器生命周期管理"><span>容器生命周期管理</span></a></h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><code>docker run</code></td><td><code>docker run -d --name mynginx nginx</code></td><td>创建并启动一个名为 <code>mynginx</code> 的 Nginx 容器，<code>-d</code> 表示后台运行</td></tr><tr><td><code>docker start</code></td><td><code>docker start mynginx</code></td><td>启动名为 <code>mynginx</code> 的已停止容器</td></tr><tr><td><code>docker stop</code></td><td><code>docker stop mynginx</code></td><td>停止名为 <code>mynginx</code> 的运行中容器</td></tr><tr><td><code>docker restart</code></td><td><code>docker restart mynginx</code></td><td>重启名为 <code>mynginx</code> 的容器</td></tr><tr><td><code>docker kill</code></td><td><code>docker kill mynginx</code></td><td>强制停止名为 <code>mynginx</code> 的容器</td></tr><tr><td><code>docker rm</code></td><td><code>docker rm mynginx</code></td><td>删除名为 <code>mynginx</code> 的已停止容器</td></tr><tr><td><code>docker pause</code></td><td><code>docker pause mynginx</code></td><td>暂停名为 <code>mynginx</code> 的容器</td></tr><tr><td><code>docker unpause</code></td><td><code>docker unpause mynginx</code></td><td>恢复名为 <code>mynginx</code> 的容器</td></tr></tbody></table><h3 id="容器查看" tabindex="-1"><a class="header-anchor" href="#容器查看"><span>容器查看</span></a></h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><code>docker ps</code></td><td><code>docker ps</code></td><td>列出当前运行中的容器</td></tr><tr><td><code>docker container ls</code></td><td><code>docker container ls -a</code></td><td>列出所有容器，包括停止的</td></tr><tr><td><code>docker inspect</code></td><td><code>docker inspect mynginx</code></td><td>获取名为 <code>mynginx</code> 的容器的详细信息</td></tr></tbody></table><p>在 Docker 的上下文中，<code>ps</code> 和 <code>ls</code> 命令都用于列出信息，但它们针对的对象和提供的功能有所不同：</p><p><code>docker ps</code></p><ul><li><strong>用途</strong>：<code>docker ps</code> 命令用于列出当前运行中的容器。</li><li><strong>默认行为</strong>：默认情况下，<code>docker ps</code> 只显示当前正在运行的容器。</li><li><strong>选项</strong>： <ul><li><code>-a</code>：列出所有容器（包括停止的容器）。</li><li><code>-q</code>：只显示容器 ID。</li><li><code>-s</code>：显示容器的大小。</li><li>其他选项可用于过滤和格式化输出。</li></ul></li></ul><p><code>docker container ls</code></p><ul><li><p><strong>用途</strong>：<code>docker container ls</code> 命令用于列出容器的信息。</p></li><li><p><strong>默认行为</strong>：与 <code>docker ps</code> 类似，默认情况下，<code>docker container ls</code> 只显示当前正在运行的容器。</p></li><li><p><strong>选项</strong>：</p><ul><li><code>-a</code>：列出所有容器（包括停止的容器）。</li><li><code>-q</code>：只显示容器 ID。</li><li><code>-s</code>：显示容器的大小。</li><li>其他选项与 <code>docker ps</code> 命令相似。</li></ul></li><li><p><strong>历史和命名</strong>：<code>docker ps</code> 是 Docker 早期版本中的命令，后来随着 Docker 命令行界面（CLI）的更新，引入了更结构化的命令格式，如 <code>docker container ls</code>。尽管 <code>docker ps</code> 仍然可用，但 <code>docker container ls</code> 更符合 Docker 命令的现代命名约定。</p></li><li><p><strong>功能</strong>：实际上，<code>docker ps</code> 和 <code>docker container ls</code> 在功能上是相同的。它们接受相同的选项，并执行相同的操作。使用哪一个主要取决于个人习惯或特定脚本的要求。 在实践中，你可以根据自己的偏好选择使用 <code>docker ps</code> 或 <code>docker container ls</code>，它们都会提供相同的结果。不过，要注意的是，随着 Docker 的不断更新，未来可能会有新的命令和选项被引入。</p></li></ul><h3 id="镜像管理" tabindex="-1"><a class="header-anchor" href="#镜像管理"><span>镜像管理</span></a></h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><code>docker images</code></td><td><code>docker images</code></td><td>列出本地所有镜像</td></tr><tr><td><code>docker pull</code></td><td><code>docker pull nginx:latest</code></td><td>从 Docker Hub 拉取最新版的 Nginx 镜像</td></tr><tr><td><code>docker rmi</code></td><td><code>docker rmi nginx:latest</code></td><td>删除本地名为 <code>nginx:latest</code> 的镜像</td></tr><tr><td><code>docker build</code></td><td><code>docker build -t myapp .</code></td><td>使用当前目录的 Dockerfile 构建名为 <code>myapp</code> 的镜像</td></tr><tr><td><code>docker tag</code></td><td><code>docker tag myapp:latest myregistry.com/myapp:latest</code></td><td>将本地镜像 <code>myapp:latest</code> 标记为 <code>myregistry.com/myapp:latest</code></td></tr><tr><td><code>docker push</code></td><td><code>docker push myregistry.com/myapp:latest</code></td><td>将本地镜像推送到 <code>myregistry.com</code> 仓库</td></tr></tbody></table><h3 id="网络管理" tabindex="-1"><a class="header-anchor" href="#网络管理"><span>网络管理</span></a></h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><code>docker network ls</code></td><td><code>docker network ls</code></td><td>列出所有 Docker 网络</td></tr><tr><td><code>docker network create</code></td><td><code>docker network create mynet</code></td><td>创建名为 <code>mynet</code> 的新网络</td></tr><tr><td><code>docker network rm</code></td><td><code>docker network rm mynet</code></td><td>删除名为 <code>mynet</code> 的网络</td></tr></tbody></table><h3 id="数据管理" tabindex="-1"><a class="header-anchor" href="#数据管理"><span>数据管理</span></a></h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><code>docker volume create</code></td><td><code>docker volume create mydata</code></td><td>创建名为 <code>mydata</code> 的新卷</td></tr><tr><td><code>docker volume ls</code></td><td><code>docker volume ls</code></td><td>列出所有 Docker 卷</td></tr><tr><td><code>docker volume rm</code></td><td><code>docker volume rm mydata</code></td><td>删除名为 <code>mydata</code> 的卷</td></tr></tbody></table><h3 id="系统日志" tabindex="-1"><a class="header-anchor" href="#系统日志"><span>系统日志</span></a></h3><table><thead><tr><th>命令</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><code>docker logs</code></td><td><code>docker logs mynginx</code></td><td>获取名为 <code>mynginx</code> 的容器的日志输出</td></tr><tr><td><code>docker logs -f</code></td><td><code>docker logs -f mynginx</code></td><td>动态获取名为 <code>mynginx</code> 的容器的日志输出</td></tr></tbody></table><h2 id="命令" tabindex="-1"><a class="header-anchor" href="#命令"><span>命令</span></a></h2><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> container</span><span style="color:#F1FA8C;"> rm</span><span style="color:#F8F8F2;"> $(</span><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> ps</span><span style="color:#BD93F9;"> -aq</span><span style="color:#F8F8F2;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>$() 是一个命令替换（command substitution）的语法，它允许你将一个命令的输出作为另一个命令的参数</p><ul><li>docker ps -aq：这个命令列出所有容器的 ID（包括运行中和已停止的容器），其中 -a 表示列出所有容器，-q 表示只显示容器 ID。</li><li>$(...)：将 docker ps -aq 命令的输出（即所有容器的 ID 列表）作为参数传递给 docker container rm 命令。</li></ul><table><thead><tr><th>选项</th><th>简写</th><th>说明</th></tr></thead><tbody><tr><td><code>--interactive</code></td><td><code>-i</code></td><td>交互模式，即使没有附加终端，也保持 STDIN 打开。</td></tr><tr><td><code>--tty</code></td><td><code>-t</code></td><td>分配一个伪终端。</td></tr><tr><td><code>--detach</code></td><td><code>-d</code></td><td>后台运行模式，在后台运行容器并打印容器 ID。</td></tr><tr><td><code>--publish</code></td><td><code>-p</code></td><td>将容器的端口映射到宿主机。</td></tr><tr><td><code>--volume</code></td><td><code>-v</code></td><td>绑定挂载宿主机的卷到容器内。</td></tr><tr><td><code>--name</code></td><td></td><td>为容器指定一个名称。</td></tr><tr><td><code>--rm</code></td><td></td><td>当容器退出时自动删除容器。</td></tr><tr><td><code>--env</code></td><td><code>-e</code></td><td>设置环境变量。</td></tr><tr><td><code>--network</code></td><td></td><td>将容器连接到指定的网络。</td></tr><tr><td><code>--restart</code></td><td></td><td>设置容器的重启策略（例如，<code>always</code>, <code>on-failure</code>, <code>unless-stopped</code>）。</td></tr><tr><td><code>--user</code></td><td><code>-u</code></td><td>指定运行容器的用户名或 UID。</td></tr><tr><td><code>--cpus</code></td><td></td><td>限制容器可以使用的 CPU 数量。</td></tr><tr><td><code>--memory</code></td><td><code>-m</code></td><td>限制容器可以使用的内存量。</td></tr><tr><td><code>--memory-swap</code></td><td></td><td>限制容器可以使用的内存和交换空间总量。</td></tr><tr><td><code>--cpu-shares</code></td><td></td><td>设置 CPU 使用权重（相对权重）。</td></tr><tr><td><code>--cpuset-cpus</code></td><td></td><td>限制容器可以使用的 CPU（例如，<code>0-3</code>，<code>1,3</code>）。</td></tr><tr><td><code>--hostname</code></td><td></td><td>设置容器的主机名。</td></tr><tr><td><code>--workdir</code></td><td><code>-w</code></td><td>为容器设置工作目录。</td></tr><tr><td><code>--entrypoint</code></td><td></td><td>覆盖容器默认的 <code>ENTRYPOINT</code>。</td></tr><tr><td><code>--cmd</code></td><td></td><td>覆盖容器的默认命令（<code>CMD</code>）。</td></tr></tbody></table><h2 id="attached和detached" tabindex="-1"><a class="header-anchor" href="#attached和detached"><span>attached和detached</span></a></h2><ul><li><strong>attached</strong>：在 <code>docker run</code> 命令中，如果使用 <code>-it</code> 选项，容器将会以交互模式运行，并且命令行会附加到容器中。这意味着你可以直接在命令行中与容器进行交互，例如运行 shell 命令、编辑文件等。这种模式通常用于调试和开发。</li><li><strong>detached</strong>：在 <code>docker run</code> 命令中，如果使用 <code>-d</code> 选项，容器将会在后台运行，并且命令行会与容器分离。这意味着你可以关闭命令行窗口，容器将继续运行。这种模式通常用于运行长期运行的服务，例如 web 服务器、数据库等。</li></ul><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;"># 前台执行</span></span>
<span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> container</span><span style="color:#F1FA8C;"> run</span><span style="color:#BD93F9;"> -p</span><span style="color:#F1FA8C;"> 80:80</span><span style="color:#F1FA8C;"> nginx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>访问直接输出了日志 <img src="`+r+'" alt="" loading="lazy"><img src="'+s+'" alt="" loading="lazy"><img src="'+c+'" alt="" loading="lazy"></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> run</span><span style="color:#BD93F9;"> -d</span><span style="color:#BD93F9;"> -p</span><span style="color:#F1FA8C;"> 80:80</span><span style="color:#F1FA8C;"> nginx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="连接容器的shell" tabindex="-1"><a class="header-anchor" href="#连接容器的shell"><span>连接容器的shell</span></a></h2><h3 id="创建一个容器并进入交互模式" tabindex="-1"><a class="header-anchor" href="#创建一个容器并进入交互模式"><span>创建一个容器并进入交互模式</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> run</span><span style="color:#BD93F9;"> -it</span><span style="color:#F1FA8C;">  my_container</span><span style="color:#F1FA8C;">  sh</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="进入一个运行的容器" tabindex="-1"><a class="header-anchor" href="#进入一个运行的容器"><span>进入一个运行的容器</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">docker</span><span style="color:#F1FA8C;"> exec</span><span style="color:#BD93F9;"> -it</span><span style="color:#F1FA8C;"> container_id</span><span style="color:#F1FA8C;"> sh</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在指定的运行中的容器内执行一个新进程</p><ul><li>i：交互模式，即使没有附加终端，也保持 STDIN 打开。</li><li>t：分配一个伪终端。</li><li>container_id：你需要执行命令的容器的唯一标识符。</li><li>sh：在容器内部启动的进程。这里，sh 是一个 shell 程序，它会启动一个新的 shell 环境，允许你与容器内的操作系统进行交互。</li></ul><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="container和虚拟机" tabindex="-1"><a class="header-anchor" href="#container和虚拟机"><span>container和虚拟机</span></a></h2><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器和虚拟机（Virtual Machines, VMs）是两种不同的技术，它们在软件部署和应用隔离方面各有优势。</p><h3 id="容器-containers" tabindex="-1"><a class="header-anchor" href="#容器-containers"><span>容器（Containers）</span></a></h3><ul><li><strong>定义</strong>：容器是一种轻量级的、可移植的、自给自足的软件打包技术。它们包含应用程序及其所有依赖项，如库、框架和设置，以便在各种环境中一致地运行。</li><li><strong>技术原理</strong>：容器使用宿主机的内核，共享宿主机的操作系统，但它们有自己的文件系统、网络栈和进程空间。</li><li><strong>优势</strong>： <ul><li><strong>启动速度快</strong>：容器直接在宿主机的内核上运行，启动时间非常短。</li><li><strong>资源利用率高</strong>：容器共享宿主机的操作系统内核，因此它们比虚拟机更节省资源。</li><li><strong>易于迁移和扩展</strong>：容器可以在任何支持它们的平台上运行，使得应用程序的迁移和扩展变得简单。</li><li><strong>隔离性</strong>：容器提供了一个相对轻量级的隔离环境，可以确保应用程序的安全性和稳定性。</li></ul></li></ul><h3 id="虚拟机-virtual-machines" tabindex="-1"><a class="header-anchor" href="#虚拟机-virtual-machines"><span>虚拟机（Virtual Machines）</span></a></h3><ul><li><p><strong>定义</strong>：虚拟机是一种软件层，它允许在一台物理服务器上运行多个操作系统。每个虚拟机都模拟了物理硬件，包括CPU、内存、硬盘等。</p></li><li><p><strong>技术原理</strong>：虚拟机使用虚拟化技术，在物理硬件上模拟出一个或多个物理机器，每个虚拟机都有自己的操作系统和硬件资源。</p></li><li><p><strong>优势</strong>：</p><ul><li><strong>隔离性强</strong>：虚拟机提供了完整的硬件模拟，每个虚拟机之间完全隔离，可以运行不同的操作系统和应用程序。</li><li><strong>灵活性和可扩展性</strong>：虚拟机可以在需要时增加或减少资源，易于扩展。</li><li><strong>易于备份和恢复</strong>：虚拟机可以作为一个文件进行备份和恢复，方便进行数据保护和灾难恢复。</li><li><strong>安全性</strong>：虚拟机提供了硬件级别的隔离，使得每个虚拟机都是一个安全的沙箱环境。</li></ul></li><li><p>容器不是mini虚拟机</p></li><li><p>容器是进程组，共享宿主机的内核，共享资源，隔离环境</p></li><li><p>虚拟机是完整的操作系统，有完整的内核，不共享资源，隔离环境</p></li></ul><h2 id="容器的创建" tabindex="-1"><a class="header-anchor" href="#容器的创建"><span>容器的创建</span></a></h2><ol><li><strong>镜像选择</strong>： <ul><li>Docker 首先检查本地存储是否有指定的镜像。如果没有，它会尝试从 Docker Hub 或您指定的镜像仓库中拉取镜像。</li></ul></li><li><strong>镜像解包</strong>： <ul><li>如果镜像不在本地，Docker 会从仓库下载镜像，并将镜像的层（layers）逐层解包到内存中。这个过程称为镜像的解包。</li></ul></li><li><strong>创建容器文件系统</strong>： <ul><li>Docker 使用镜像的顶层文件系统来创建容器的文件系统。如果这是从仓库拉取的镜像，它将使用仓库中的最新层。</li></ul></li><li><strong>设置容器上下文</strong>： <ul><li>Docker 创建一个与容器相关的上下文，包括命令行参数、环境变量、卷、端口映射等。</li></ul></li><li><strong>命名和标识</strong>： <ul><li>Docker 为新容器分配一个唯一的标识符（通常是一个 64 位的数字），并可能为其分配一个名称。</li></ul></li><li><strong>网络配置</strong>： <ul><li>Docker 配置容器的网络接口，包括设置 IP 地址、端口映射、创建网络命名空间等。</li></ul></li><li><strong>进程管理</strong>： <ul><li>Docker 创建一个或多个进程来运行容器的应用。这些进程通常是容器镜像中定义的 <code>ENTRYPOINT</code> 或 <code>CMD</code> 指令指定的命令。</li></ul></li><li><strong>资源限制</strong>： <ul><li>Docker 设置容器的资源限制，如 CPU、内存、进程限制等。</li></ul></li><li><strong>生命周期管理</strong>： <ul><li>Docker 管理容器的生命周期，包括启动、停止、重启等操作。</li></ul></li><li><strong>日志和监控</strong>： <ul><li>Docker 收集和记录容器的日志，并可能监控容器的性能和状态。 在整个过程中，Docker 使用其核心组件（如 Docker 引擎、Docker 客户端、Docker 守护进程等）来执行这些操作。这些组件共同工作，确保容器能够按照预期的方式运行。</li></ul></li></ol><h1 id="image-1" tabindex="-1"><a class="header-anchor" href="#image-1"><span>Image</span></a></h1><h2 id="镜像的获取" tabindex="-1"><a class="header-anchor" href="#镜像的获取"><span>镜像的获取</span></a></h2><ul><li>pull from registry</li><li>build from Dockerfile</li><li>load from file</li></ul>',61)]))}const y=t(h,[["render",u],["__file","base.html.vue"]]),b=JSON.parse('{"path":"/docker/base.html","title":"Docker 基础","lang":"en-US","frontmatter":{"title":"Docker 基础","icon":"docker","date":"2024-11-16T00:00:00.000Z","category":["Docker"],"tag":["Docker"],"description":"CLI docker version Client: 表示 Docker 客户端的版本信息。 Docker Engine - Community: Docker 客户端的类型，这里是社区版。 Version: 客户端的版本号。 API version: 客户端支持的最高 Docker API 版本。 Go version: 构建 Docker 客户端所...","head":[["meta",{"property":"og:url","content":"https://luxiag.github.io/luxiag/blog/docker/base.html"}],["meta",{"property":"og:title","content":"Docker 基础"}],["meta",{"property":"og:description","content":"CLI docker version Client: 表示 Docker 客户端的版本信息。 Docker Engine - Community: Docker 客户端的类型，这里是社区版。 Version: 客户端的版本号。 API version: 客户端支持的最高 Docker API 版本。 Go version: 构建 Docker 客户端所..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-24T12:22:33.000Z"}],["meta",{"property":"article:tag","content":"Docker"}],["meta",{"property":"article:published_time","content":"2024-11-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-24T12:22:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker 基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-24T12:22:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luxiag\\",\\"url\\":\\"https://luxiag.github.io/luxiag\\"}]}"]]},"headers":[{"level":2,"title":"Image","slug":"image","link":"#image","children":[]},{"level":2,"title":"container","slug":"container","link":"#container","children":[]},{"level":2,"title":"常用命令","slug":"常用命令","link":"#常用命令","children":[{"level":3,"title":"容器生命周期管理","slug":"容器生命周期管理","link":"#容器生命周期管理","children":[]},{"level":3,"title":"容器查看","slug":"容器查看","link":"#容器查看","children":[]},{"level":3,"title":"镜像管理","slug":"镜像管理","link":"#镜像管理","children":[]},{"level":3,"title":"网络管理","slug":"网络管理","link":"#网络管理","children":[]},{"level":3,"title":"数据管理","slug":"数据管理","link":"#数据管理","children":[]},{"level":3,"title":"系统日志","slug":"系统日志","link":"#系统日志","children":[]}]},{"level":2,"title":"命令","slug":"命令","link":"#命令","children":[]},{"level":2,"title":"attached和detached","slug":"attached和detached","link":"#attached和detached","children":[]},{"level":2,"title":"连接容器的shell","slug":"连接容器的shell","link":"#连接容器的shell","children":[{"level":3,"title":"创建一个容器并进入交互模式","slug":"创建一个容器并进入交互模式","link":"#创建一个容器并进入交互模式","children":[]},{"level":3,"title":"进入一个运行的容器","slug":"进入一个运行的容器","link":"#进入一个运行的容器","children":[]}]},{"level":2,"title":"container和虚拟机","slug":"container和虚拟机","link":"#container和虚拟机","children":[{"level":3,"title":"容器（Containers）","slug":"容器-containers","link":"#容器-containers","children":[]},{"level":3,"title":"虚拟机（Virtual Machines）","slug":"虚拟机-virtual-machines","link":"#虚拟机-virtual-machines","children":[]}]},{"level":2,"title":"容器的创建","slug":"容器的创建","link":"#容器的创建","children":[]},{"level":2,"title":"镜像的获取","slug":"镜像的获取","link":"#镜像的获取","children":[]}],"git":{"createdTime":1732450953000,"updatedTime":1732450953000,"contributors":[{"name":"luxiag","email":"luxiag@qq.com","commits":1}]},"readingTime":{"minutes":10.19,"words":3058},"filePathRelative":"docker/base.md","localizedDate":"November 16, 2024","excerpt":"\\n<p><code>docker version</code></p>\\n<figure><figcaption></figcaption></figure>\\n<ul>\\n<li><strong>Client</strong>: 表示 Docker 客户端的版本信息。\\n<ul>\\n<li><strong>Docker Engine - Community</strong>: Docker 客户端的类型，这里是社区版。</li>\\n<li><strong>Version</strong>: 客户端的版本号。</li>\\n<li><strong>API version</strong>: 客户端支持的最高 Docker API 版本。</li>\\n<li><strong>Go version</strong>: 构建 Docker 客户端所使用的 Go 语言版本。</li>\\n<li><strong>Git commit</strong>: 客户端版本的 Git 提交哈希值。</li>\\n<li><strong>Built</strong>: 客户端构建的时间。</li>\\n<li><strong>OS/Arch</strong>: 客户端运行的操作系统和架构。</li>\\n<li><strong>Experimental</strong>: 表示是否启用了实验性功能。</li>\\n</ul>\\n</li>\\n<li><strong>Server</strong>: 表示 Docker 服务器的版本信息，通常指的是 Docker 引擎。\\n<ul>\\n<li><strong>Engine</strong>: Docker 引擎的详细版本信息。\\n<ul>\\n<li><strong>Version</strong>: 引擎的版本号。</li>\\n<li><strong>API version</strong>: 引擎支持的 Docker API 版本，后面通常会注明最低支持的 API 版本。</li>\\n<li><strong>Go version</strong>: 构建 Docker 引擎所使用的 Go 语言版本。</li>\\n<li><strong>Git commit</strong>: 引擎版本的 Git 提交哈希值。</li>\\n<li><strong>Built</strong>: 引擎构建的时间。</li>\\n<li><strong>OS/Arch</strong>: 引擎运行的操作系统和架构。</li>\\n<li><strong>Experimental</strong>: 表示是否启用了实验性功能。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{y as comp,b as data};
