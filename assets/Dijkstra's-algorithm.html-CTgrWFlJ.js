import{_ as n,c as a,b as l,o as p}from"./app-DmuFHWsy.js";const e="/blog/assets/168012340-11-22-16-58-00-C0oCsQ31.png",o={};function F(t,s){return p(),a("div",null,s[0]||(s[0]=[l('<h2 id="狄克斯特拉算法" tabindex="-1"><a class="header-anchor" href="#狄克斯特拉算法"><span>狄克斯特拉算法</span></a></h2><p><strong>Dijkstra 算法是一种贪心算法</strong></p><ul><li>(1) 找出最便宜的节点，即可在最短时间内前往的节点。</li><li>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。</li><li>(3) 重复这个过程，直到对图中的每个节点都这样做了。</li><li>(4) 计算最终路径。</li></ul><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;">//A B C D E F</span></span>
<span class="line"><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> graph </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> [</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//A  A=&gt;B=2 A=&gt;C=4</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//B  B=&gt;C=1 B=&gt;D=4 B=&gt;E=2</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//C</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//D</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">3</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//E</span></span>
<span class="line"><span style="color:#F8F8F2;">  [</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">, </span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">], </span><span style="color:#6272A4;">//F</span></span>
<span class="line"><span style="color:#F8F8F2;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;">// graph 邻接矩阵</span></span>
<span class="line"><span style="color:#6272A4;">// src 起点</span></span>
<span class="line"><span style="color:#FF79C6;">const</span><span style="color:#50FA7B;"> dijkstra</span><span style="color:#FF79C6;"> =</span><span style="color:#F8F8F2;"> (</span><span style="color:#FFB86C;font-style:italic;">graph</span><span style="color:#FF79C6;">:</span><span style="color:#8BE9FD;font-style:italic;"> number</span><span style="color:#F8F8F2;">[][], </span><span style="color:#FFB86C;font-style:italic;">src</span><span style="color:#FF79C6;">:</span><span style="color:#8BE9FD;font-style:italic;"> number</span><span style="color:#F8F8F2;">) </span><span style="color:#FF79C6;">=&gt;</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> dist </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> []; </span><span style="color:#6272A4;">// 储存当前A顶点到其它各个顶点间的距离</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> visited </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> []; </span><span style="color:#6272A4;">//储存ABCDEF顶点是否被访问过，以免重复访问，形成环</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> length </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> graph.length; </span><span style="color:#6272A4;">//储存所有顶点的数量</span></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> INF </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> Number.MAX_SAFE_INTEGER; </span><span style="color:#6272A4;">//Number javascript的最大整数  9007199254740991</span></span>
<span class="line"><span style="color:#6272A4;">  //初始化</span></span>
<span class="line"><span style="color:#FF79C6;">  for</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">; i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> length; i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    dist[i] </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> INF;</span></span>
<span class="line"><span style="color:#F8F8F2;">    visited[i] </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> false</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#6272A4;">  //第一个节点</span></span>
<span class="line"><span style="color:#F8F8F2;">  dist[src] </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">  let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">  while</span><span style="color:#F8F8F2;"> (i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> length </span><span style="color:#FF79C6;">-</span><span style="color:#BD93F9;"> 1</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#6272A4;">    //此时对应节点 已经访问设置 true</span></span>
<span class="line"><span style="color:#F8F8F2;">    visited[src] </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> true</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#6272A4;">    //找到对应节点 的 对应的边集合</span></span>
<span class="line"><span style="color:#FF79C6;">    let</span><span style="color:#F8F8F2;"> currentEdges </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> graph[src];</span></span>
<span class="line"><span style="color:#6272A4;">    //遍历边,更新路径</span></span>
<span class="line"><span style="color:#FF79C6;">    for</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">; i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> currentEdges.length; i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#FF79C6;">      if</span><span style="color:#F8F8F2;"> (currentEdges[i] </span><span style="color:#FF79C6;">!==</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#6272A4;">        //存在边 , 找到最短路径  例如</span></span>
<span class="line"><span style="color:#6272A4;">        //A=&gt;B=&gt;C 最短路径的权</span></span>
<span class="line"><span style="color:#6272A4;">        //为 A=&gt;B 的权(dist[src]) +  B=&gt;C的权(currentEdegs[i]) 和 A=&gt;C(dist[i]) 的权 进行比较</span></span>
<span class="line"><span style="color:#FF79C6;">        if</span><span style="color:#F8F8F2;"> (dist[src] </span><span style="color:#FF79C6;">+</span><span style="color:#F8F8F2;"> currentEdges[i] </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> dist[i]) {</span></span>
<span class="line"><span style="color:#6272A4;">          //符合上面条件 更新dist[i] 保证dist[i]是每次探路的最短路径</span></span>
<span class="line"><span style="color:#F8F8F2;">          dist[i] </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> currentEdges[i] </span><span style="color:#FF79C6;">+</span><span style="color:#F8F8F2;"> dist[src];</span></span>
<span class="line"><span style="color:#F8F8F2;">        }</span></span>
<span class="line"><span style="color:#F8F8F2;">      }</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"><span style="color:#6272A4;">    //迪杰斯特拉的核心算法 , 找到最短路径 重新探路.</span></span>
<span class="line"><span style="color:#6272A4;">    //选择最短路径</span></span>
<span class="line"><span style="color:#FF79C6;">    let</span><span style="color:#F8F8F2;"> min </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> INF;</span></span>
<span class="line"><span style="color:#FF79C6;">    let</span><span style="color:#F8F8F2;"> minIndex </span><span style="color:#FF79C6;">=</span><span style="color:#FF79C6;"> -</span><span style="color:#BD93F9;">2</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">    for</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#FF79C6;">=</span><span style="color:#BD93F9;"> 0</span><span style="color:#F8F8F2;">; i </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> dist.length; i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#FF79C6;">      if</span><span style="color:#F8F8F2;"> (</span><span style="color:#FF79C6;">!</span><span style="color:#F8F8F2;">visited[i] </span><span style="color:#FF79C6;">&amp;&amp;</span><span style="color:#F8F8F2;"> dist[i] </span><span style="color:#FF79C6;">&lt;</span><span style="color:#F8F8F2;"> min) {</span></span>
<span class="line"><span style="color:#F8F8F2;">        min </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> dist[i];</span></span>
<span class="line"><span style="color:#F8F8F2;">        minIndex </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> i;</span></span>
<span class="line"><span style="color:#F8F8F2;">      }</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6272A4;">    //进入下一次循环</span></span>
<span class="line"><span style="color:#F8F8F2;">    src </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> minIndex;</span></span>
<span class="line"><span style="color:#F8F8F2;">    i</span><span style="color:#FF79C6;">++</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#FF79C6;">  return</span><span style="color:#F8F8F2;"> dist;</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考：https://zhuanlan.zhihu.com/p/114203860</p>`,7)]))}const r=n(o,[["render",F],["__file","Dijkstra's-algorithm.html.vue"]]),i=JSON.parse(`{"path":"/algorithm/Dijkstra's-algorithm.html","title":"狄克斯特拉算法","lang":"en-US","frontmatter":{"title":"狄克斯特拉算法","reference":"算法图解","date":"2022-09-30T00:00:00.000Z","category":["算法"],"tag":["算法图解"],"description":"狄克斯特拉算法 Dijkstra 算法是一种贪心算法 (1) 找出最便宜的节点，即可在最短时间内前往的节点。 (2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。 参考：https://zhuanlan.zhihu.com/p/114203860","head":[["meta",{"property":"og:url","content":"https://luxiag.github.io/luxiag/blog/algorithm/Dijkstra's-algorithm.html"}],["meta",{"property":"og:title","content":"狄克斯特拉算法"}],["meta",{"property":"og:description","content":"狄克斯特拉算法 Dijkstra 算法是一种贪心算法 (1) 找出最便宜的节点，即可在最短时间内前往的节点。 (2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。 参考：https://zhuanlan.zhihu.com/p/114203860"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2022-12-05T10:02:18.000Z"}],["meta",{"property":"article:tag","content":"算法图解"}],["meta",{"property":"article:published_time","content":"2022-09-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-12-05T10:02:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"狄克斯特拉算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-09-30T00:00:00.000Z\\",\\"dateModified\\":\\"2022-12-05T10:02:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luxiag\\",\\"url\\":\\"https://luxiag.github.io/luxiag\\"}]}"]]},"headers":[{"level":2,"title":"狄克斯特拉算法","slug":"狄克斯特拉算法","link":"#狄克斯特拉算法","children":[]}],"git":{"createdTime":1664978887000,"updatedTime":1670234538000,"contributors":[{"name":"luxiang","email":"luxiag@qq.com","commits":2},{"name":"卢祥","email":"example@qq.com","commits":2},{"name":"卢祥","email":"example@email.com","commits":1},{"name":"卢祥","email":"example@gmail.com","commits":1}]},"readingTime":{"minutes":1.74,"words":523},"filePathRelative":"algorithm/Dijkstra's-algorithm.md","localizedDate":"September 30, 2022","excerpt":"<h2>狄克斯特拉算法</h2>\\n<p><strong>Dijkstra 算法是一种贪心算法</strong></p>\\n<ul>\\n<li>(1) 找出最便宜的节点，即可在最短时间内前往的节点。</li>\\n<li>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。</li>\\n<li>(3) 重复这个过程，直到对图中的每个节点都这样做了。</li>\\n<li>(4) 计算最终路径。</li>\\n</ul>","autoDesc":true}`);export{r as comp,i as data};
