import{_ as a,c as t,a as n,o as s}from"./app-BtF4yjxr.js";const l="/assets/231001604122942222-BXm3Go2K.png",i="/assets/886001704122942222-BexQ593k.png",r="/assets/495002104122942222-Ab4IDX0v.png",o="/assets/322001504122942222-B0yXk9ja.png",p="/assets/348005703122942222-Bw_fgFZw.png",c="/assets/705005803122942222-CrHS3fq_.png",d="/assets/612005903122942222-DN0kCYxO.png",h="/assets/900005903122942222-C1tgg21w.png",g="/assets/013000804122942222-Cxgo-Yk1.png",m={};function u(f,e){return s(),t("div",null,e[0]||(e[0]=[n('<figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="performance" tabindex="-1"><a class="header-anchor" href="#performance"><span>Performance</span></a></h2><p><img src="'+i+'" alt="" loading="lazy"><img src="'+r+`" alt="" loading="lazy"></p><h2 id="diff-算法的优化" tabindex="-1"><a class="header-anchor" href="#diff-算法的优化"><span>diff 算法的优化</span></a></h2><p>vue2 中的虚拟 dom 是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上）</p><p>vue3 新增了静态标记（patchflag）与上次虚拟节点对比时，只对比带有 patch flag 的节点（动态数据所在的节点）；可通过 flag 信息得知当前节点要对比的具体内容。</p><h2 id="hoiststatic-静态提升" tabindex="-1"><a class="header-anchor" href="#hoiststatic-静态提升"><span>hoistStatic 静态提升</span></a></h2><p>vue2无论元素是否参与更新，每次都会重新创建然后再渲染。 vue3对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可。</p><h2 id="更高效的组件初始化" tabindex="-1"><a class="header-anchor" href="#更高效的组件初始化"><span>更高效的组件初始化</span></a></h2><p>Vue2组件必须有一个跟节点</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" data-title="vue" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#F8F8F2;">&lt;</span><span style="color:#FF79C6;">template</span><span style="color:#F8F8F2;">&gt;</span></span>
<span class="line"><span style="color:#F8F8F2;">&lt;</span><span style="color:#FF79C6;">div</span><span style="color:#F8F8F2;">&gt;1&lt;/</span><span style="color:#FF79C6;">div</span><span style="color:#F8F8F2;">&gt;</span></span>
<span class="line"><span style="color:#F8F8F2;">&lt;</span><span style="color:#FF79C6;">div</span><span style="color:#F8F8F2;">&gt;2&lt;/</span><span style="color:#FF79C6;">div</span><span style="color:#F8F8F2;">&gt;</span></span>
<span class="line"><span style="color:#F8F8F2;">&lt;/</span><span style="color:#FF79C6;">template</span><span style="color:#F8F8F2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cachehandlers-事件侦听器缓存" tabindex="-1"><a class="header-anchor" href="#cachehandlers-事件侦听器缓存"><span>cacheHandlers 事件侦听器缓存</span></a></h3><p>vue2.x中，绑定事件每次触发都要重新生成全新的function去更新，cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新。 默认情况下onClick会被视为动态绑定，所以每次都会追踪它的变化，但是同一个函数没必要追踪变化，直接缓存起来复用即可。</p><h2 id="three-shaking" tabindex="-1"><a class="header-anchor" href="#three-shaking"><span>Three Shaking</span></a></h2><p><img src="`+o+'" alt="" loading="lazy"> Vue 3.0 中没有被用到的模块可以不被打包到编译后的文件中，被 TreeShake 掉。当只有一个HelloWorld的时候 Vue3打包后 13.5kb。所有的组件全部加载进来时是 22.5kb</p><h2 id="更好的ts支持" tabindex="-1"><a class="header-anchor" href="#更好的ts支持"><span>更好的ts支持</span></a></h2><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="composition-api" tabindex="-1"><a class="header-anchor" href="#composition-api"><span>Composition API</span></a></h2><p><img src="'+c+'" alt="" loading="lazy"><img src="'+d+'" alt="" loading="lazy"></p><h2 id="fragment" tabindex="-1"><a class="header-anchor" href="#fragment"><span>Fragment</span></a></h2><p><img src="'+h+'" alt="" loading="lazy"> 类似于react的&lt;&gt;&lt;/&gt;</p><h2 id="teleport" tabindex="-1"><a class="header-anchor" href="#teleport"><span>Teleport</span></a></h2><p><img src="'+g+'" alt="" loading="lazy"> 类似react的 portal <strong>但因为Chrome有个提案，会增加一个名为Portal的原生element，为避免命名冲突，改为Teleport</strong></p>',23)]))}const F=a(m,[["render",u],["__file","vue3-and-vue2.html.vue"]]),y=JSON.parse('{"path":"/vue3/vue3-and-vue2.html","title":"Vue3 对比 Vue2","lang":"en-US","frontmatter":{"title":"Vue3 对比 Vue2","date":"2022-12-01T00:00:00.000Z","category":["Vue"],"tag":["vue3"],"description":"Performance diff 算法的优化 vue2 中的虚拟 dom 是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上） vue3 新增了静态标记（patchflag）与上次虚拟节点对比时，只对比带有 patch flag 的节点（动态数据所在的节点）；可通过 flag 信息得知当前节点要对比的具体内...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/vue3/vue3-and-vue2.html"}],["meta",{"property":"og:title","content":"Vue3 对比 Vue2"}],["meta",{"property":"og:description","content":"Performance diff 算法的优化 vue2 中的虚拟 dom 是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上） vue3 新增了静态标记（patchflag）与上次虚拟节点对比时，只对比带有 patch flag 的节点（动态数据所在的节点）；可通过 flag 信息得知当前节点要对比的具体内..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2022-12-30T06:28:03.000Z"}],["meta",{"property":"article:tag","content":"vue3"}],["meta",{"property":"article:published_time","content":"2022-12-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-12-30T06:28:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue3 对比 Vue2\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-12-01T00:00:00.000Z\\",\\"dateModified\\":\\"2022-12-30T06:28:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luxiag\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Performance","slug":"performance","link":"#performance","children":[]},{"level":2,"title":"diff 算法的优化","slug":"diff-算法的优化","link":"#diff-算法的优化","children":[]},{"level":2,"title":"hoistStatic 静态提升","slug":"hoiststatic-静态提升","link":"#hoiststatic-静态提升","children":[]},{"level":2,"title":"更高效的组件初始化","slug":"更高效的组件初始化","link":"#更高效的组件初始化","children":[{"level":3,"title":"cacheHandlers 事件侦听器缓存","slug":"cachehandlers-事件侦听器缓存","link":"#cachehandlers-事件侦听器缓存","children":[]}]},{"level":2,"title":"Three Shaking","slug":"three-shaking","link":"#three-shaking","children":[]},{"level":2,"title":"更好的ts支持","slug":"更好的ts支持","link":"#更好的ts支持","children":[]},{"level":2,"title":"Composition API","slug":"composition-api","link":"#composition-api","children":[]},{"level":2,"title":"Fragment","slug":"fragment","link":"#fragment","children":[]},{"level":2,"title":"Teleport","slug":"teleport","link":"#teleport","children":[]}],"git":{"createdTime":1672307601000,"updatedTime":1672381683000,"contributors":[{"name":"luxiag","email":"luxiag@qq.com","commits":2}]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"vue3/vue3-and-vue2.md","localizedDate":"December 1, 2022","excerpt":"<figure><figcaption></figcaption></figure>\\n<h2>Performance</h2>\\n<p>\\n</p>\\n<h2>diff 算法的优化</h2>\\n<p>vue2 中的虚拟 dom 是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上）</p>","autoDesc":true}');export{F as comp,y as data};
