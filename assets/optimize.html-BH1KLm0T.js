import{_ as a,e,h as n,o as l}from"./app-DPJYBgB6.js";const t="/blog/assets/1144171745494445975-CNG6rxUA.png",i="/blog/assets/1144171745494667922-DXPl1Td6.png",r={};function o(p,s){return l(),e("div",null,s[0]||(s[0]=[n('<h2 id="判断是否变慢" tabindex="-1"><a class="header-anchor" href="#判断是否变慢"><span>判断是否变慢</span></a></h2><p>在较高的配置基准下（比如 8C 16G +），在连接数为0~10000的时候，最高QPS可达到120000。Redis以超过60000个连接为基准，仍然能够在这些条件下维持50000个q/s，体现了超高的性能。下图中横轴是连接数，纵轴是QPS。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="基线延迟测试" tabindex="-1"><a class="header-anchor" href="#基线延迟测试"><span>基线延迟测试</span></a></h3><p>redis-cli 提供了一个指令选项 --intrinsic-latency，用于监测和统计某个时间段内Redis的最大延迟。 <img src="'+i+`" alt="" loading="lazy"> 可以在终端上连接Redis的服务端进行测试，避免客户端测试因为网络的影响导致差异较大。 可以通过-h host -p port 来连接到服务端。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">redis-cli</span><span style="color:#BD93F9;"> --latency</span><span style="color:#BD93F9;"> -h</span><span style="color:#F1FA8C;"> \`</span><span style="color:#50FA7B;">host</span><span style="color:#F1FA8C;">\`</span><span style="color:#50FA7B;"> -p</span><span style="color:#F1FA8C;"> \`</span><span style="color:#50FA7B;">port</span><span style="color:#F1FA8C;">\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="复杂度过高" tabindex="-1"><a class="header-anchor" href="#复杂度过高"><span>复杂度过高</span></a></h2><p>查看Redis慢日志</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#6272A4;"># 命令执行耗时超过 5 毫秒，记录慢日志</span></span>
<span class="line"><span style="color:#50FA7B;">CONFIG</span><span style="color:#F1FA8C;"> SET</span><span style="color:#F1FA8C;"> slowlog-log-slower-than</span><span style="color:#BD93F9;"> 5000</span></span>
<span class="line"><span style="color:#6272A4;"># 只保留最近 500 条慢日志</span></span>
<span class="line"><span style="color:#50FA7B;">CONFIG</span><span style="color:#F1FA8C;"> SET</span><span style="color:#F1FA8C;"> slowlog-max-len</span><span style="color:#BD93F9;"> 500</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询到最近记录的慢日志</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">127.0.0.1:6379</span><span style="color:#F8F8F2;">&gt; </span><span style="color:#F1FA8C;">SLOWLOG</span><span style="color:#F1FA8C;"> get</span><span style="color:#BD93F9;"> 5</span></span>
<span class="line"><span style="color:#50FA7B;">1</span><span style="color:#F8F8F2;">) 1) (</span><span style="color:#50FA7B;">integer</span><span style="color:#F8F8F2;">) 32693       </span><span style="color:#6272A4;"># 慢日志ID</span></span>
<span class="line"><span style="color:#50FA7B;">   2</span><span style="color:#F8F8F2;">) (</span><span style="color:#50FA7B;">integer</span><span style="color:#F8F8F2;">) 1593763337  </span><span style="color:#6272A4;"># 执行时间戳</span></span>
<span class="line"><span style="color:#50FA7B;">   3</span><span style="color:#F8F8F2;">) (</span><span style="color:#50FA7B;">integer</span><span style="color:#F8F8F2;">) 5299        </span><span style="color:#6272A4;"># 执行耗时(微秒)</span></span>
<span class="line"><span style="color:#50FA7B;">   4</span><span style="color:#F8F8F2;">) 1) </span><span style="color:#E9F284;">&quot;</span><span style="color:#F1FA8C;">LRANGE</span><span style="color:#E9F284;">&quot;</span><span style="color:#6272A4;">           # 具体执行的命令和参数</span></span>
<span class="line"><span style="color:#50FA7B;">      2</span><span style="color:#F8F8F2;">) </span><span style="color:#E9F284;">&quot;</span><span style="color:#F1FA8C;">user_list:2000</span><span style="color:#E9F284;">&quot;</span></span>
<span class="line"><span style="color:#50FA7B;">      3</span><span style="color:#F8F8F2;">) </span><span style="color:#E9F284;">&quot;</span><span style="color:#F1FA8C;">0</span><span style="color:#E9F284;">&quot;</span></span>
<span class="line"><span style="color:#50FA7B;">      4</span><span style="color:#F8F8F2;">) </span><span style="color:#E9F284;">&quot;</span><span style="color:#F1FA8C;">-1</span><span style="color:#E9F284;">&quot;</span></span>
<span class="line"><span style="color:#50FA7B;">2</span><span style="color:#F8F8F2;">) 1) (</span><span style="color:#50FA7B;">integer</span><span style="color:#F8F8F2;">) 32692</span></span>
<span class="line"><span style="color:#50FA7B;">   2</span><span style="color:#F8F8F2;">) (</span><span style="color:#50FA7B;">integer</span><span style="color:#F8F8F2;">) 1593763337</span></span>
<span class="line"><span style="color:#50FA7B;">   3</span><span style="color:#F8F8F2;">) (</span><span style="color:#50FA7B;">integer</span><span style="color:#F8F8F2;">) 5044</span></span>
<span class="line"><span style="color:#50FA7B;">   4</span><span style="color:#F8F8F2;">) 1) </span><span style="color:#E9F284;">&quot;</span><span style="color:#F1FA8C;">GET</span><span style="color:#E9F284;">&quot;</span></span>
<span class="line"><span style="color:#50FA7B;">      2</span><span style="color:#F8F8F2;">) </span><span style="color:#E9F284;">&quot;</span><span style="color:#F1FA8C;">user_info:1000</span><span style="color:#E9F284;">&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bigkey" tabindex="-1"><a class="header-anchor" href="#bigkey"><span>bigKey</span></a></h3><p><strong>如果一个 key 写入的 value 非常大，那么 Redis 在分配内存时就会比较耗时。</strong></p><p>在 Redis 中，<strong>Big Key（大键）</strong> 指的是占用内存较大或元素数量非常多的键。定位这些键对于优化性能、避免阻塞是非常重要的。</p><hr><h3 id="🎯-为什么要扫描-bigkey" tabindex="-1"><a class="header-anchor" href="#🎯-为什么要扫描-bigkey"><span>🎯 为什么要扫描 BigKey？</span></a></h3><ul><li>某个 key 占了过多内存，可能导致 Redis 内存不够或性能变差</li><li>删除或访问某些大 key 会造成阻塞，影响整个实例</li><li>定位数据倾斜问题</li></ul><hr><h3 id="🧰-一些常用的方法-重点推荐前两种" tabindex="-1"><a class="header-anchor" href="#🧰-一些常用的方法-重点推荐前两种"><span>🧰 一些常用的方法（重点推荐前两种）</span></a></h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>1️⃣ <code>redis-cli --bigkeys</code></td><td>官方工具，快速扫描整个数据库的大 key（推荐）</td></tr><tr><td>2️⃣ 使用 SCAN + TYPE + DEBUG OBJECT</td><td>手动逐个扫描 key 判断大小</td></tr><tr><td>3️⃣ 使用 <code>MEMORY USAGE key</code> 命令</td><td>精确查看某个 key 占用的字节数</td></tr><tr><td>4️⃣ 使用 AOF/RDB 分析工具</td><td>离线分析数据文件，查看大 key 分布</td></tr></tbody></table><hr><h3 id="✅-方法一-使用-redis-cli-bigkeys-强烈推荐" tabindex="-1"><a class="header-anchor" href="#✅-方法一-使用-redis-cli-bigkeys-强烈推荐"><span>✅ 方法一：使用 <code>redis-cli --bigkeys</code>（强烈推荐）</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">redis-cli</span><span style="color:#BD93F9;"> --bigkeys</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>📌 输出示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span># Scanning the entire keyspace to find biggest keys as well as average sizes per key type.</span></span>
<span class="line"><span># Press ctrl-c to stop at any time.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[00.00%] Biggest string found so far &#39;log:debug&#39; with 834245 bytes</span></span>
<span class="line"><span>[10.00%] Biggest list found so far &#39;queue:pending&#39; with 12500 items</span></span>
<span class="line"><span></span></span>
<span class="line"><span>------ summary ------</span></span>
<span class="line"><span>Sampled 10000 keys</span></span>
<span class="line"><span>Total key length in bytes is 123456 (avg len 12.35)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Biggest string: log:debug (834245 bytes)</span></span>
<span class="line"><span>Biggest list: queue:pending (12500 items)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="✅-方法二-scan-手动分析-key-用于自动化脚本" tabindex="-1"><a class="header-anchor" href="#✅-方法二-scan-手动分析-key-用于自动化脚本"><span>✅ 方法二：SCAN + 手动分析 key（用于自动化脚本）</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">SCAN</span><span style="color:#BD93F9;"> 0</span><span style="color:#F1FA8C;"> COUNT</span><span style="color:#BD93F9;"> 1000</span></span>
<span class="line"><span style="color:#50FA7B;">TYPE</span><span style="color:#F1FA8C;"> yourkey</span></span>
<span class="line"><span style="color:#50FA7B;">MEMORY</span><span style="color:#F1FA8C;"> USAGE</span><span style="color:#F1FA8C;"> yourkey</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例脚本（伪代码逻辑）：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">SCAN</span><span style="color:#F1FA8C;"> cursor</span></span>
<span class="line"><span style="color:#50FA7B;">→</span><span style="color:#F1FA8C;"> 对每个</span><span style="color:#F1FA8C;"> key</span><span style="color:#F1FA8C;"> 调用</span><span style="color:#F1FA8C;"> TYPE</span><span style="color:#F1FA8C;"> key</span></span>
<span class="line"><span style="color:#50FA7B;">→</span><span style="color:#F1FA8C;"> 如果是</span><span style="color:#F1FA8C;"> list/set/zset/hash：</span></span>
<span class="line"><span style="color:#50FA7B;">   →</span><span style="color:#F1FA8C;"> 用</span><span style="color:#F1FA8C;"> LLEN</span><span style="color:#F1FA8C;"> /</span><span style="color:#F1FA8C;"> SCARD</span><span style="color:#F1FA8C;"> /</span><span style="color:#F1FA8C;"> ZCARD</span><span style="color:#F1FA8C;"> /</span><span style="color:#F1FA8C;"> HLEN</span><span style="color:#F1FA8C;"> 查看大小</span></span>
<span class="line"><span style="color:#50FA7B;">→</span><span style="color:#F1FA8C;"> 用</span><span style="color:#F1FA8C;"> MEMORY</span><span style="color:#F1FA8C;"> USAGE</span><span style="color:#F1FA8C;"> key</span><span style="color:#F1FA8C;"> 查看内存占用</span></span>
<span class="line"><span style="color:#50FA7B;">→</span><span style="color:#F1FA8C;"> 如果超过阈值就报警</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你也可以用 C# 自动化调用这个流程，写个 <code>RedisBigKeyScanner</code> 小工具类。</p><hr><h3 id="🔬-方法三-查看单个-key-占用内存" tabindex="-1"><a class="header-anchor" href="#🔬-方法三-查看单个-key-占用内存"><span>🔬 方法三：查看单个 key 占用内存</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#50FA7B;">MEMORY</span><span style="color:#F1FA8C;"> USAGE</span><span style="color:#F1FA8C;"> mykey</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>返回值为 <strong>字节数（bytes）</strong>。</p><hr><h3 id="🔎-方法四-分析-rdb-aof-文件-适合大规模排查" tabindex="-1"><a class="header-anchor" href="#🔎-方法四-分析-rdb-aof-文件-适合大规模排查"><span>🔎 方法四：分析 RDB/AOF 文件（适合大规模排查）</span></a></h3><p>工具包括：</p><ul><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener noreferrer"><code>redis-rdb-tools</code></a></li><li><a href="https://github.com/hit9/rdr" target="_blank" rel="noopener noreferrer"><code>rdr</code></a></li><li><a href="https://github.com/RedisLabs/aof-tools" target="_blank" rel="noopener noreferrer"><code>aof-tools</code></a></li></ul><hr><h3 id="⚠️-redis-中常见的大-key-类型-要重点关注" tabindex="-1"><a class="header-anchor" href="#⚠️-redis-中常见的大-key-类型-要重点关注"><span>⚠️ Redis 中常见的大 key 类型（要重点关注）</span></a></h3><table><thead><tr><th>类型</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>List</td><td>LLEN key</td><td>太长可能会阻塞</td></tr><tr><td>Hash</td><td>HLEN key</td><td>太大不适合用作对象存储</td></tr><tr><td>Set</td><td>SCARD key</td><td>元素过多迭代会卡顿</td></tr><tr><td>ZSet</td><td>ZCARD key</td><td>排行榜、打分场景中易成为大 key</td></tr><tr><td>String</td><td>MEMORY USAGE key</td><td>图片、日志、大 JSON 字符串可能很大</td></tr></tbody></table><hr><h2 id="集中过期" tabindex="-1"><a class="header-anchor" href="#集中过期"><span>集中过期</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-performance.html" target="_blank" rel="noopener noreferrer">Redis进阶 - 性能调优：Redis性能调优详解</a></li><li><a href="https://www.cnblogs.com/wzh2010/p/17205492.html" target="_blank" rel="noopener noreferrer">Redis系列23： 性能优化指南</a></li></ul>`,46)]))}const d=a(r,[["render",o],["__file","optimize.html.vue"]]),F=JSON.parse('{"path":"/redis/optimize.html","title":"Redis性能调优","lang":"en-US","frontmatter":{"title":"Redis性能调优","category":["Redis"],"date":"2025-04-24T00:00:00.000Z","description":"判断是否变慢 在较高的配置基准下（比如 8C 16G +），在连接数为0~10000的时候，最高QPS可达到120000。Redis以超过60000个连接为基准，仍然能够在这些条件下维持50000个q/s，体现了超高的性能。下图中横轴是连接数，纵轴是QPS。 基线延迟测试 redis-cli 提供了一个指令选项 --intrinsic-latency，...","head":[["meta",{"property":"og:url","content":"https://luxiag.github.io/luxiag/blog/redis/optimize.html"}],["meta",{"property":"og:title","content":"Redis性能调优"}],["meta",{"property":"og:description","content":"判断是否变慢 在较高的配置基准下（比如 8C 16G +），在连接数为0~10000的时候，最高QPS可达到120000。Redis以超过60000个连接为基准，仍然能够在这些条件下维持50000个q/s，体现了超高的性能。下图中横轴是连接数，纵轴是QPS。 基线延迟测试 redis-cli 提供了一个指令选项 --intrinsic-latency，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-05-06T13:43:02.000Z"}],["meta",{"property":"article:published_time","content":"2025-04-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-06T13:43:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis性能调优\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-06T13:43:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luxiag\\",\\"url\\":\\"https://luxiag.github.io/luxiag\\"}]}"]]},"git":{"createdTime":1730043043000,"updatedTime":1746538982000,"contributors":[{"name":"luxiag","username":"luxiag","email":"luxiag@qq.com","commits":3,"url":"https://github.com/luxiag"}]},"readingTime":{"minutes":3.13,"words":938},"filePathRelative":"redis/optimize.md","localizedDate":"April 24, 2025","excerpt":"<h2>判断是否变慢</h2>\\n<p>在较高的配置基准下（比如 8C 16G +），在连接数为0~10000的时候，最高QPS可达到120000。Redis以超过60000个连接为基准，仍然能够在这些条件下维持50000个q/s，体现了超高的性能。下图中横轴是连接数，纵轴是QPS。</p>","autoDesc":true}');export{d as comp,F as data};
