import{l as x,b as D,m as L,n as k,o as A,p as G,q as E,W as w,r as T,s as R}from"./three.module-DS1BwEFu.js";import{O as f}from"./OrbitControls-DPkMXWBp.js";import{_ as H,h as p,i as b,c as P,a as F,b as e,o as q}from"./app-DsmKNl15.js";const M={__name:"glsl-hello.html",setup(C,{expose:s}){s();const l=o=>{const r=new x,_=new R,i={u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new D}},a=new L(75,2,.1,1e3);a.position.set(0,0,10),r.add(a);const S=new k({uniforms:i,fragmentShader:o.fragmentShader,side:A}),B=new G(new E(10,10),S);r.add(B);const n=new w;n.setSize(o.shaderDom.value.offsetWidth,o.shaderDom.value.offsetWidth/2),n.shadowMap.enabled=!0,o.shaderDom.value.appendChild(n.domElement),n.render(r,a);const g=new f(a,n.domElement);g.enableDamping=!0,i.u_resolution.value.x=n.domElement.width,i.u_resolution.value.y=n.domElement.height;function h(){i.u_time.value+=_.getDelta(),g.update(),n.render(r,a),requestAnimationFrame(h)}h()},t=p(),c={fragmentShader:`
        #ifdef GL_ES
        precision mediump float;
        #endif
        void main(){
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
        }
        `,shaderDom:t},d=p(),m={fragmentShader:`
    #ifdef GL_ES
    precision mediump float;
    #endif

    uniform float u_time;

    void main() {
     gl_FragColor = vec4(abs(sin(u_time)),0.0,0.0,1.0);
    }
    `,shaderDom:d},u=p(),y={fragmentShader:`
    #ifdef GL_ES
    precision mediump float;
    #endif

    uniform vec2 u_resolution;
    uniform vec2 u_mouse;
    uniform float u_time;

    void main() {
     vec2 st = gl_FragCoord.xy/u_resolution;
     gl_FragColor = vec4(st.x,st.y,0.0,1.0);
    }`,shaderDom:u};b(()=>{l(c),l(m),l(y)});const v={initScene:l,helloRef:t,helloShader:c,timeRef:d,timeShader:m,fragRef:u,fragShader:y,get THREE(){return T},ref:p,onMounted:b,get OrbitControls(){return f}};return Object.defineProperty(v,"__isScriptSetup",{enumerable:!1,value:!0}),v}},O={ref:"helloRef"},Z={ref:"timeRef"},W={ref:"fragRef"};function $(C,s,l,t,c,d){return q(),P("div",null,[s[0]||(s[0]=F(`<p>参考：《The Book of Shaders》</p><h2 id="fragment-shader-片段着色器" tabindex="-1"><a class="header-anchor" href="#fragment-shader-片段着色器"><span>Fragment Shader(片段着色器)</span></a></h2><div class="language-glsl line-numbers-mode" data-highlighter="shiki" data-ext="glsl" data-title="glsl" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#FF79C6;">#ifdef</span><span style="color:#50FA7B;"> GL_ES</span></span>
<span class="line"><span style="color:#F8F8F2;">precision mediump </span><span style="color:#FF79C6;">float</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">uniform</span><span style="color:#FF79C6;"> float</span><span style="color:#F8F8F2;"> u_time;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">void</span><span style="color:#50FA7B;"> main</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;"> gl_FragColor </span><span style="color:#FF79C6;">=</span><span style="color:#50FA7B;"> vec4</span><span style="color:#F8F8F2;">(</span><span style="color:#BD93F9;">1.0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">0.0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">1.0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">1.0</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),e("div",O,null,512),s[1]||(s[1]=F(`<p><strong>Shaders 是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。</strong></p><ul><li><p>shader 语言 有一个 main 函数，会在最后返回颜色值。这点和 C 语言很像。</p></li><li><p>最终的像素颜色取决于预设的全局变量 gl_FragColor。</p></li><li><p>这个类 C 语言有内建的变量（像 gl_FragColor），函数和数据类型。</p></li><li><p>vec4 类型，可以推测这四个变元分别响应红，绿，蓝和透明度通道。</p></li><li><p>所有的宏都以 # 开头。预编译会在编译前一刻发生，把所有的命令复制到 #defines 里，检查#ifdef 条件句是否已被定义， #ifndef 条件句是否没有被定义。</p></li><li><p>loat 类型在 shaders 中非常重要，所以精度非常重要。更低的精度会有更快的渲染速度，但是会以质量为代价。“低”（precision lowp float;），“高”（precision highp float;）。</p></li><li><p>GLSL 语言规范并不保证变量会被自动转换类别。</p></li></ul><div class="language-glsl line-numbers-mode" data-highlighter="shiki" data-ext="glsl" data-title="glsl" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#FF79C6;">void</span><span style="color:#50FA7B;"> main</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    gl_FragColor </span><span style="color:#FF79C6;">=</span><span style="color:#50FA7B;"> vec4</span><span style="color:#F8F8F2;">(</span><span style="color:#BD93F9;">1</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">1</span><span style="color:#F8F8F2;">);</span><span style="color:#6272A4;">   // 出错</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="uniform" tabindex="-1"><a class="header-anchor" href="#uniform"><span>uniform</span></a></h2><p>每个线程和其他线程之间不能有数据交换，但我们能从 CPU 给每个线程输入数据。因为显卡的架构，所有线程的输入值必须统一（uniform），而且必须设为只读。 输入值叫做 uniform （统一值），它们的数据类型通常为：float, vec2, vec3, vec4, mat2, mat3, mat4, sampler2D and samplerCube。</p><div class="language-glsl line-numbers-mode" data-highlighter="shiki" data-ext="glsl" data-title="glsl" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"><span style="color:#FF79C6;">#ifdef</span><span style="color:#50FA7B;"> GL_ES</span></span>
<span class="line"><span style="color:#F8F8F2;">precision mediump </span><span style="color:#FF79C6;">float</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">uniform</span><span style="color:#FF79C6;"> float</span><span style="color:#F8F8F2;"> u_time;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">void</span><span style="color:#50FA7B;"> main</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;"> gl_FragColor </span><span style="color:#FF79C6;">=</span><span style="color:#50FA7B;"> vec4</span><span style="color:#F8F8F2;">(</span><span style="color:#50FA7B;">abs</span><span style="color:#F8F8F2;">(</span><span style="color:#50FA7B;">sin</span><span style="color:#F8F8F2;">(u_time)),</span><span style="color:#BD93F9;">0.0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">0.0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">1.0</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6)),e("div",Z,null,512),s[2]||(s[2]=F(`<h2 id="gl-fragcoord" tabindex="-1"><a class="header-anchor" href="#gl-fragcoord"><span>gl_FragCoord</span></a></h2><p>gl_FragCoord存储了活动线程正在处理的像素或屏幕碎片的坐标。 因为每个像素的坐标都不同，所以我们把它叫做 varying <strong>（变化值）</strong>。</p><div class="language-glsl line-numbers-mode" data-highlighter="shiki" data-ext="glsl" data-title="glsl" style="background-color:#282A36;color:#F8F8F2;"><pre class="shiki dracula vp-code"><code><span class="line"></span>
<span class="line"><span style="color:#FF79C6;">#ifdef</span><span style="color:#50FA7B;"> GL_ES</span></span>
<span class="line"><span style="color:#F8F8F2;">precision mediump </span><span style="color:#FF79C6;">float</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FF79C6;">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">uniform</span><span style="color:#FF79C6;"> vec2</span><span style="color:#F8F8F2;"> u_resolution;</span></span>
<span class="line"><span style="color:#FF79C6;">uniform</span><span style="color:#FF79C6;"> vec2</span><span style="color:#F8F8F2;"> u_mouse;</span></span>
<span class="line"><span style="color:#FF79C6;">uniform</span><span style="color:#FF79C6;"> float</span><span style="color:#F8F8F2;"> u_time;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6;">void</span><span style="color:#50FA7B;"> main</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">vec2 st </span><span style="color:#FF79C6;">=</span><span style="color:#F8F8F2;"> gl_FragCoord.xy</span><span style="color:#FF79C6;">/</span><span style="color:#F8F8F2;">u_resolution;</span></span>
<span class="line"><span style="color:#F8F8F2;">gl_FragColor </span><span style="color:#FF79C6;">=</span><span style="color:#50FA7B;"> vec4</span><span style="color:#F8F8F2;">(st.x,st.y,</span><span style="color:#BD93F9;">0.0</span><span style="color:#F8F8F2;">,</span><span style="color:#BD93F9;">1.0</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),e("div",W,null,512),s[3]||(s[3]=e("h2",{id:"glsl",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#glsl"},[e("span",null,"GLSL")])],-1)),s[4]||(s[4]=e("p",null,"GLSL 代表 openGL Shading Language，openGL 着色语言",-1)),s[5]||(s[5]=e("iframe",{src:"https://openglbook.com/chapter-0-preface-what-is-opengl.html",style:{width:"100%"},height:"800px"},null,-1))])}const j=H(M,[["render",$],["__file","glsl-hello.html.vue"]]),z=JSON.parse('{"path":"/glsl/glsl-hello.html","title":"Hello GLSL","lang":"en-US","frontmatter":{"title":"Hello GLSL","category":["GLSL"],"date":"2022-10-01T00:00:00.000Z","description":"参考：《The Book of Shaders》 Fragment Shader(片段着色器) Shaders 是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。 shader 语言 有一个 main 函数，会在最后返回颜色值。这点和 C 语言很像。 最终的像素颜色取决于预设的全局变量 gl_FragColor。 这个类 C 语言有内建的变量（...","head":[["meta",{"property":"og:url","content":"https://luxiag.github.io/luxiag/blog/glsl/glsl-hello.html"}],["meta",{"property":"og:title","content":"Hello GLSL"}],["meta",{"property":"og:description","content":"参考：《The Book of Shaders》 Fragment Shader(片段着色器) Shaders 是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。 shader 语言 有一个 main 函数，会在最后返回颜色值。这点和 C 语言很像。 最终的像素颜色取决于预设的全局变量 gl_FragColor。 这个类 C 语言有内建的变量（..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-10-31T11:40:02.000Z"}],["meta",{"property":"article:published_time","content":"2022-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-31T11:40:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Hello GLSL\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-10-31T11:40:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"luxiag\\",\\"url\\":\\"https://luxiag.github.io/luxiag\\"}]}"]]},"headers":[{"level":2,"title":"Fragment Shader(片段着色器)","slug":"fragment-shader-片段着色器","link":"#fragment-shader-片段着色器","children":[]},{"level":2,"title":"uniform","slug":"uniform","link":"#uniform","children":[]},{"level":2,"title":"gl_FragCoord","slug":"gl-fragcoord","link":"#gl-fragcoord","children":[]},{"level":2,"title":"GLSL","slug":"glsl","link":"#glsl","children":[]}],"git":{"createdTime":1671175256000,"updatedTime":1730374802000,"contributors":[{"name":"luxiag","email":"luxiag@qq.com","commits":12},{"name":"卢祥","email":"example@qq.com","commits":1}]},"readingTime":{"minutes":2.63,"words":789},"filePathRelative":"glsl/glsl-hello.md","localizedDate":"October 1, 2022","excerpt":"<p>参考：《The Book of Shaders》</p>\\n<h2>Fragment Shader(片段着色器)</h2>\\n<div class=\\"language-glsl line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"glsl\\" data-title=\\"glsl\\" style=\\"background-color:#282A36;color:#F8F8F2\\"><pre class=\\"shiki dracula vp-code\\"><code><span class=\\"line\\"><span style=\\"color:#FF79C6\\">#ifdef</span><span style=\\"color:#50FA7B\\"> GL_ES</span></span>\\n<span class=\\"line\\"><span style=\\"color:#F8F8F2\\">precision mediump </span><span style=\\"color:#FF79C6\\">float</span><span style=\\"color:#F8F8F2\\">;</span></span>\\n<span class=\\"line\\"><span style=\\"color:#FF79C6\\">#endif</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"color:#FF79C6\\">uniform</span><span style=\\"color:#FF79C6\\"> float</span><span style=\\"color:#F8F8F2\\"> u_time;</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"color:#FF79C6\\">void</span><span style=\\"color:#50FA7B\\"> main</span><span style=\\"color:#F8F8F2\\">() {</span></span>\\n<span class=\\"line\\"><span style=\\"color:#F8F8F2\\"> gl_FragColor </span><span style=\\"color:#FF79C6\\">=</span><span style=\\"color:#50FA7B\\"> vec4</span><span style=\\"color:#F8F8F2\\">(</span><span style=\\"color:#BD93F9\\">1.0</span><span style=\\"color:#F8F8F2\\">,</span><span style=\\"color:#BD93F9\\">0.0</span><span style=\\"color:#F8F8F2\\">,</span><span style=\\"color:#BD93F9\\">1.0</span><span style=\\"color:#F8F8F2\\">,</span><span style=\\"color:#BD93F9\\">1.0</span><span style=\\"color:#F8F8F2\\">);</span></span>\\n<span class=\\"line\\"><span style=\\"color:#F8F8F2\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{j as comp,z as data};
