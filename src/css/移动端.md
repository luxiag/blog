---
date: 2022-01-01

category:
 - css
tag: 
 - 移动端
---


# 移动端

## **英寸**

一般用英寸描述屏幕的物理大小，如电脑显示器的17、22，手机显示器的4.8、5.7等使用的单位都是英寸

英寸(inch,缩写为in)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。

英寸和厘米的换算：1英寸 = 2.54 厘米

## **分辨率**

### **像素**

像素即一个小方块，它具有特定的位置和颜色。

图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。

像素可以作为图片或电子屏幕的最小组成单位

### **屏幕分辨率**

屏幕分辨率指一个屏幕具体由多少个像素点组成。

### **图像分辨率**

图片分辨率其实是指图片含有的像素数，比如一张图片的分辨率为800 x 400。这表示图片分别在垂直和水平上所具有的像素点数为800和400。

同一尺寸的图片，分辨率越高，图片越清晰。

### **PPI**

PPI(Pixel Per Inch)：每英寸包括的像素数。

PPI可以用于描述屏幕的清晰度以及一张图片的质量。

使用PPI描述图片时，PPI越高，图片质量越高，使用PPI描述屏幕时，PPI越高，屏幕越清晰。

### **DPI**

DPI(Dot Per Inch)：即每英寸包括的点数。

到使用DPI来描述图片和屏幕，这时的DPI应该和PPI是等价的，DPI最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。

一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。

当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是DPI所描述的：打印点的密度。

## **设备独立像素**

描述的像素都是物理像素，即设备上真实的物理单元

理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？

**现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。**

乔布斯在iPhone4的发布会上首次提出了Retina Display(视网膜屏幕)的概念，它正是解决了上面的问题

在iPhone4使用的视网膜屏幕中，把2x2个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。

**设备独立像素(Device Independent Pixels)简称DIP或DP**告诉不同分辨率的手机，它们在界面上显示元素的大小是多少

打开chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如iPhone X显示的尺寸是375x812，实际iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。

### **设备像素比**

设备像素比`device pixel ratio`简称`dpr`，即物理像素和设备独立像素的比值。

在web中，浏览器为我们提供了`window.devicePixelRatio`来帮助我们获取dpr。

在css中，可以使用媒体查询`min-device-pixel-ratio`，区分dpr：

### **Web开发**

在写CSS时，我们用到最多的单位是px，即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。

但是CSS像素是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。

页面的缩放系数 = CSS像素 / 设备独立像素。

### **关于屏幕**

`Retina`屏幕只是苹果提出的一个营销术语：

`a=2arctan(h/2d)`

a代表人眼视角，h 代表像素间距，d代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。

让多个物理像素渲染一个独立像素只是Retina屏幕为了达到效果而使用的一种技术。而不是所有DPR > 1的屏幕就是Retina屏幕。

P代表的就是屏幕纵向的像素个数，1080P即纵向有1080个像素，分辨率为1920X1080的屏幕就属于1080P屏幕。

我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过1920X1080的屏幕。

K代表屏幕横向有几个1024个像素，一般来讲横向像素超过2048就属于2K屏，横向像素超过4096就属于4K屏。

## **视口**

视口(`viewport`)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。

### **布局视口**

布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。

所以，布局视口是网页布局的基准窗口，在PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包括borders 、margins、滚动条）。

在移动端，布局视口被赋予一个默认值，大部分为980px，这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。

我们可以通过调用`document.documentElement.clientWidth / clientHeight`来获取布局视口大小。

### **视觉视口**

视觉视口(visual viewport)：用户通过屏幕真实看到的区域。

视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。

当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。

例如：用户将浏览器窗口放大了200%，这时浏览器窗口中的CSS像素会随着视觉视口的放大而放大，这时一个CSS像素会跨越更多的物理像素。

所以，布局视口会限制你的CSS布局而视觉视口决定用户具体能看到什么。

我们可以通过调用`window.innerWidth / innerHeight`来获取视觉视口大小。

### **理想视口**

布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(ideal viewport)就诞生了：网站页面在移动端展示的理想大小。

页面的缩放系数 = 理想视口宽度 / 视觉视口宽度

当页面缩放比例为100%时，CSS像素 = 设备独立像素，理想视口 = 视觉视口。

调用`screen.width / height`来获取理想视口大小。

### **Meta viewport**

```
 <meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;">
```

[Untitled](%E7%A7%BB%E5%8A%A8%E7%AB%AF%204b7c297c18e747138eda28f61bf8a014/Untitled%20Database%204f2cc3454c964f9598d6f69ce6ae035d.csv)

### **移动端适配**

为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。

device-width就等于理想视口的宽度，所以设置width=device-width就相当于让布局视口等于理想视口。

由于initial-scale = 理想视口宽度 / 视觉视口宽度，所以我们设置initial-scale=1;就相当于让视觉视口等于理想视口。

这时，1个CSS像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。

### **缩放**

width可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置initial-scale也有肯能影响到布局视口，因为布局视口宽度取的是width和视觉视口宽度的最大值。

例如：若手机的理想视口宽度为400px，设置`width=device-width`，`initial-scale=2`,此时`视觉视口宽度 = 理想视口宽度 / initial-scale`即200px，布局视口取两者最大值即`device-width 400px`。

若设置`width=device-width，initial-scale=0.5`，此时`视觉视口宽度 = 理想视口宽度 / initial-scale`即800px，布局视口取两者最大值即`800px`。

### **获取浏览器的大小**

- `window.innerHeight`：获取浏览器视觉视口高度（包括垂直滚动条）。
- `window.outerHeight`：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。
- `window.screen.Height`：获取获屏幕取理想视口高度，这个数值是固定的，设备的分辨率/设备像素比
- `window.screen.availHeight`：浏览器窗口可用的高度。
- `document.documentElement.clientHeight`：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。
- `document.documentElement.offsetHeight`：包括内边距、滚动条、边框和外边距。
- `document.documentElement.scrollHeight`：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与`clientHeight`相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。

## **1px问题**

### **border-image**

基于media查询判断不同的设备像素比给定不同的border-image：

```
 .border_1px{
     border-bottom: 1px solid #000;
 }
 @media only screen and (-webkit-min-device-pixel-ratio:2){
     .border_1px{
         border-bottom: none;
         border-width: 0 0 1px 0;
         border-image: url(../img/1pxline.png) 0 0 2 0 stretch;
     }
 }
```

### **background-image**

和border-image类似，准备一张符合条件的边框背景图，模拟在背景上。

```
 .border_1px{
     border-bottom: 1px solid #000;
 }
 @media only screen and (-webkit-min-device-pixel-ratio:2){
     .border_1px{
         background: url(../img/1pxline.png) repeat-x left bottom;
         background-size: 100% 1px;
     }
 }
```

### **伪类+transform**

```css
 .border_1px:before{
     content: '';
     position: absolute;
     top: 0;
     height: 1px;
     width: 100%;
     background-color: #000;
     transform-origin: 50% 0%;
 }
 @media only screen and (-webkit-min-device-pixel-ratio:2){
     .border_1px:before{
         transform: scaleY(0.5);
     }
 }
 @media only screen and (-webkit-min-device-pixel-ratio:3){
     .border_1px:before{
         transform: scaleY(0.33);
     }
 }
```

### **`svg`**

借助`PostCSS`的`postcss-write-svg`我们能直接使用`border-image`和`background-image`创建`svg`的1px边框：

```
 @svg border_1px {
     height: 2px;
     @rect {
         fill: var(--color, black);
         width: 100%;
         height: 50%;
     }
 }
 .example {
     border: 1px solid transparent;
     border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch;
 }
```

### **设置viewport**

通过设置缩放，让CSS像素等于真正的物理像素。

例如：当设备像素比为3时，我们将页面缩放1/3倍，这时1px等于一个真正的屏幕像素。

```
 const scale = 1 / window.devicePixelRatio;
 const viewport = document.querySelector('meta[name="viewport"]');
 if (!viewport) {
     viewport = document.createElement('meta');
     viewport.setAttribute('name', 'viewport');
     window.document.head.appendChild(viewport);
 }
 viewport.setAttribute('content', 'width=device-width,user-scalable=no,initial-scale=' + scale + ',maximum-scale=' + scale + ',minimum-scale=' + scale);
```

## **移动端适配方案**

### **flexible方案**

`flexible`方案是阿里早期开源的一个移动端适配解决方案，引用`flexible`后，我们在页面上统一使用rem来布局。

```
 // set 1rem = viewWidth / 10
 function setRemUnit () {
     var rem = docEl.clientWidth / 10
     docEl.style.fontSize = rem + 'px'
 }
 setRemUnit();
```

`rem`是相对于`html`节点的`font-size`来做计算的。

通过设置`document.documentElement.style.fontSize`就可以统一整个页面的布局标准。

上面的代码中，将html节点的`font-size`设置为页面`clientWidth`(布局视口)的`1/10`，即`1rem`就等于页面布局视口的`1/10`，这就意味着我们后面使用的rem都是按照页面比例来计算的。

这时，我们只需要将UI出的图转换为rem即可。

以iPhone6为例：布局视口为375px，则1rem = 37.5px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 37.5 = 2rem。

```
   // reset rem unit on page resize
 window.addEventListener('resize', setRemUnit)
 window.addEventListener('pageshow', function (e) {
     if (e.persisted) {
       setRemUnit()
     }
 }
```

### **vh、vw方案**

vh、vw方案即将视觉视口宽度 `window.innerWidth` 和视觉视口高度 `window.innerHeight` 等分为 100 份。

- `vw(Viewport's width)`：1vw等于视觉视口的1%
- `vh(Viewport's height)` : 1vh 为视觉视口高度的1%
- `vmin` : vw 和 vh 中的较小值
- `vmax` : 选取 vw 和 vh 中的较大值

如果视觉视口为`375px`，那么`1vw = 3.75px`，这时UI给定一个元素的宽为`75px`（设备独立像素），我们只需要将它设置为`75 / 3.75 = 20vw`

以使用PostCSS的 postcss-px-to-viewport 插件帮我们完成这个过程

**缺陷**

- `px`转换成`vw`不一定能完全整除，因此有一定的像素差。
- 比如当容器使用`vw，margin`采用`px`时，很容易造成整体宽度超过`100vw`，从而影响布局效果。当然我们也是可以避免的，例如使用`padding`代替`margin`，结合`calc()`函数使用等等..

## **适配iPhoneX**

### **安全区域**

这些手机和普通手机在外观上无外乎做了三个改动：圆角（`corners`）、刘海（`sensor housing`）和小黑条（`Home Indicator`）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。

### **viewport-fit**

viewport-fit是专门为了适配iPhoneX而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。

`contain`: 可视窗口完全包含网页内容

`cover`：网页内容完全覆盖可视窗口

默认情况下或者设置为`auto`和`contain`效果相同。

```
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
```

### **env、constant**

iOS11新增了两个CSS函数`env、constant`，用于设定安全区域与边界的距离。

- safe-area-inset-left：安全区域距离左边边界距离
- safe-area-inset-right：安全区域距离右边边界距离
- safe-area-inset-top：安全区域距离顶部边界距离
- safe-area-inset-bottom：安全区域距离底部边界距离

必须指定`viweport-fit`后才能使用这两个函数：

```
<meta name="viewport" content="viewport-fit=cover">
```

`constant`在`iOS < 11.2`的版本中生效，`env`在`iOS >= 11.2`的版本中生效

```
body {
  padding:
    env(safe-area-inset-top, 20px)
    env(safe-area-inset-right, 20px)
    env(safe-area-inset-bottom, 20px)
    env(safe-area-inset-left, 20px);
}
```

## **横屏适配**

### **JavaScript检测横屏**

`window.orientation`:获取屏幕旋转方向

```
window.addEventListener("resize", ()=>{
    if (window.orientation === 180 || window.orientation === 0) {
      // 正常方向或屏幕旋转180度
        console.log('竖屏');
    };
    if (window.orientation === 90 || window.orientation === -90 ){
       // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度
        console.log('横屏');
    }
});
```

### **CSS检测横屏**

```
@media screen and (orientation: portrait) {
  /*竖屏...*/
}
@media screen and (orientation: landscape) {
  /*横屏...*/
}
```

## **图片模糊问题**

### **产生原因**

理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果

而在`pr > 1`的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在`dpr > 1`的屏幕上就会模糊:

### **解决方案**

为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同DPR的屏幕，我们需要展示不同分辨率的图片。

如：在`dpr=2`的屏幕上展示两倍图`(@2x)`，在`dpr=3`的屏幕上展示三倍图`(@3x)`。

### **media查询**

```
.avatar{
    background-image: url(conardLi_1x.png);
}
@media only screen and (-webkit-min-device-pixel-ratio:2){
    .avatar{
        background-image: url(conardLi_2x.png);
    }
}
@media only screen and (-webkit-min-device-pixel-ratio:3){
    .avatar{
        background-image: url(conardLi_3x.png);
    }
}
```

> 只适用于背景图

### **image-set**

```
.avatar {
    background-image: -webkit-image-set( "conardLi_1x.png" 1x, "conardLi_2x.png" 2x );
}
```

> 只适用于背景图

### **srcset**

使用`img`标签的`srcset`属性，浏览器会自动根据像素密度匹配最佳显示图片：

```
<img src="conardLi_1x.png"
     srcset=" conardLi_2x.png 2x, conardLi_3x.png 3x">
```

### **JavaScript拼接图片url**

使用`window.devicePixelRatio`获取设备像素比，遍历所有图片，替换图片地址：

```
const dpr = window.devicePixelRatio;
const images =  document.querySelectorAll('img');
images.forEach((img)=>{
  img.src.replace(".", `@${dpr}x.`);
})
```

### **使用svg**

`SVG`的全称是可缩放矢量图`（Scalable Vector Graphics）`。不同于位图的基于像素，`SVG`则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。

```
<img src="conardLi.svg">

<img src="data:image/svg+xml;base64,[data]">

.avatar {
  background: url(conardLi.svg);
}
```